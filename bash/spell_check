#!/usr/bin/env python3
import os.path
import subprocess
import re
import sys

# make wordlist if it doesn't exist
if not os.path.exists("./wordlist.txt"):
    print("No wordlist.txt found!")
    generate_wordlist = input("Generate a new wordlist.txt? [y/n] ")
    if generate_wordlist == "y":
        with open("./wordlist.txt", "w") as f:
            f.writelines("# accept" + "\n\n")
            f.writelines("# reject" + "\n")
        print("Generated a new wordlist!")
    else:
        raise FileNotFoundError("Skipping wordlist.txt generation.")

# check file to check exists
check = sys.argv[1]
if not os.path.exists(check):
    raise FileNotFoundError("File to check does not exist")

# input wordlist
with open("./wordlist.txt", "r") as f:
    wordlist = f.read().split("\n\n")

# check format of wordlist
assert len(wordlist) == 2, "Incorrectly formatted wordlist"
accept = wordlist[0].split("\n")
reject = wordlist[1].split("\n")
assert accept[0] == "# accept"
assert reject[0] == "# reject"
accept = accept[1:]
reject = reject[1:]
accept = list(filter(None, accept))
reject = list(filter(None, reject))

# check accept and reject unique
accept = sorted(accept, key=str.lower)
reject = sorted(reject, key=str.lower)
unique_words = dict()

for w in accept + reject:
    if w in unique_words:
        raise ValueError(w + " is duplicated in wordlist")
    else:
        unique_words[w] = True

# rewrite wordlist
with open("./wordlist.txt", "w") as f:
    f.writelines("# accept" + "\n")
    for l in accept:
        f.writelines(l + "\n")
    f.writelines("\n")
    f.writelines("# reject" + "\n")
    for l in reject:
        f.writelines(l + "\n")

# write temp accept
with open("./.spell_accept.tmp", "w") as f:
    f.writelines("personal_ws-1.1 en 1000 utf-8" + "\n")
    for l in accept:
        f.writelines(l + "\n")

# write temp reject
with open("./.spell_reject.tmp", "w") as f:
    f.writelines("personal_ws-1.1 en 1000 utf-8" + "\n")
    for l in reject:
        f.writelines(l + "\n")

# write temp check
cmd = ["cp", check, ".spell_check.tmp"]
output = subprocess.check_output(cmd)

# aspell with accept
accept_mistakes = subprocess.check_output(
    'bash -c "cat .spell_check.tmp | \
    aspell --home-dir=. --personal=.spell_accept.tmp -t list"',
    shell=True)
accept_mistakes = accept_mistakes.decode("utf-8").split("\n")
accept_mistakes = list(filter(None, accept_mistakes))
accept_mistakes = list(set(accept_mistakes))

# format mistakes
mistakes = []
with open(check, "r") as f:
    fsplit = f.read().split("\n")
    for l in range(len(fsplit)):
        for w in accept_mistakes + reject:
            if re.search(r"\b" + w + r"\b", fsplit[l]):
                mistakes += [[l, w, fsplit[l]]]

# check aspell treats accept as errors
aspell_accept_errors = subprocess.check_output(
    'bash -c "cat .spell_accept.tmp | \
    tail -n +2 | \
    aspell --home-dir=. -t list"',
    shell=True)
aspell_accept_errors = aspell_accept_errors.decode("ascii").split("\n")
aspell_accept_errors = list(filter(None, aspell_accept_errors))
assert accept == aspell_accept_errors, "accept should be treated as errors by aspell"

# check aspell treats reject as ok
aspell_reject_errors = subprocess.check_output(
    'bash -c "cat .spell_reject.tmp | \
    tail -n +2 | \
    aspell --home-dir=. -t list"',
    shell=True)
aspell_reject_errors = aspell_reject_errors.decode("ascii").split("\n")
aspell_reject_errors = list(filter(None, aspell_reject_errors))
assert aspell_reject_errors == [], "reject should be treated as correct by aspell"

# clean up
try:
    os.remove(".spell_accept.tmp")
except:
    "No .spell_accept.tmp file to clean"

try:
    os.remove(".spell_reject.tmp")
except:
    "No .spell_reject.tmp file to clean"

try:
    os.remove(".spell_check.tmp")
except:
    "No .spell_check.tmp file to clean"

# output results
if len(mistakes) > 0:
    header = "\033[0;33m\033[1m" + check + "\033[00m\033[0m"
    print(header)

for m in mistakes:
    linenum = "\033[0;32m\033[1m" + str(m[0] + 1) + ":\033[00m\033[0m"
    word = m[1]
    line = m[2]
    line = re.sub(word, "\033[0;31m\033[1m" + word + "\033[00m\033[0m", line)
    print(linenum + " " + line)
